<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Air Piano Pro - Corrected Mirror</title>
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js" crossorigin="anonymous"></script>

    <style>
        :root { --neon: #00f2ff; --rec: #ff4d4d; --play: #00ff88; }
        body { margin: 0; background: #000; color: white; overflow: hidden; font-family: 'Courier New', Courier, monospace; }
        /* We remove the CSS transform: scaleX(-1) to fix the inverted text/hands */
        canvas { width: 100vw; height: 100vh; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.9); z-index: 100; }
        .hidden { display: none !important; }
        #status-bar { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-around; font-weight: bold; font-size: 1.2rem; }
        .btn-start { padding: 20px 50px; background: var(--neon); border: none; border-radius: 5px; cursor: pointer; font-size: 1.5rem; }
    </style>
</head>
<body>

    <div id="welcome" class="overlay">
        <h1>TRUE-MIRROR PIANO</h1>
        <p>Right Fist: REC | Left Fist: PLAY | Both Fists: CLEAR</p>
        <button class="btn-start" onclick="initApp()">START ENGINE</button>
    </div>

    <div id="status-bar">
        <span id="rec-ui">REC: OFF</span>
        <span id="play-ui">LOOP: READY</span>
    </div>

    <canvas id="output_canvas"></canvas>
    <video id="input_video" style="display:none" playsinline></video>

<script>
let synth, recording = [], isRecording = false, isPlaying = false, loopStartTime = 0;
const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('output_canvas');
const canvasCtx = canvasElement.getContext('2d');

// 12 Notes for full finger range
const pianoNotes = ['C3', 'D3', 'E3', 'F3', 'G3', 'A3', 'B3', 'C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5'];
let fingerStates = {};
let drops = [];

async function initApp() {
    await Tone.start();
    synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "triangle" },
        envelope: { attack: 0.05, release: 1.5 }
    }).toDestination();
    document.getElementById('welcome').classList.add('hidden');
    startCamera();
}

// Detect if hand is closed (Fist)
function isFist(landmarks) {
    // Distance between wrist (0) and middle fingertip (12)
    const dist = Math.hypot(landmarks[12].x - landmarks[0].x, landmarks[12].y - landmarks[0].y);
    return dist < 0.2; 
}

function spawnDrop(x, y, note) {
    drops.push({ x, y, note, alpha: 1.0 });
}

function onResults(results) {
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

    // Draw Falling Drops
    drops.forEach((d, i) => {
        d.y += 5; d.alpha -= 0.02;
        canvasCtx.fillStyle = `rgba(0, 242, 255, ${d.alpha})`;
        canvasCtx.fillText(d.note, d.x, d.y);
        if (d.alpha <= 0) drops.splice(i, 1);
    });

    if (results.multiHandLandmarks && results.multiHandedness) {
        let rightFist = false;
        let leftFist = false;

        results.multiHandLandmarks.forEach((landmarks, hIdx) => {
            // Correcting Mirror: MediaPipe "Left" is actually "Right" when looking at screen
            let side = results.multiHandedness[hIdx].label === "Left" ? "Right" : "Left";
            
            if (isFist(landmarks)) {
                if (side === "Right") rightFist = true;
                if (side === "Left") leftFist = true;
            }

            // Finger Mapping
            const tips = [4, 8, 12, 16, 20];
            const names = ["Thumb", "Index", "Middle", "Ring", "Pinky"];

            tips.forEach((id, fIdx) => {
                const tip = landmarks[id];
                // Manual Mirroring: (1 - tip.x) maps right to right, left to left
                const x = (1 - tip.x) * canvasElement.width;
                const y = tip.y * canvasElement.height;
                
                // Bend Rule: Tip Y is lower than the joint
                const isBent = tip.y > landmarks[id-1].y;
                const key = `${side}_${names[fIdx]}`;

                if (isBent && !fingerStates[key] && !isFist(landmarks)) {
                    // Map X position to the pianoNotes array (Right = High, Left = Low)
                    const noteIdx = Math.floor((1 - tip.x) * (pianoNotes.length - 1));
                    const note = pianoNotes[noteIdx];
                    
                    synth.triggerAttackRelease(note, "4n");
                    spawnDrop(x, y, note);
                    
                    if (isRecording) {
                        recording.push({ note, time: Date.now() - loopStartTime });
                    }
                    fingerStates[key] = true;
                } else if (!isBent) {
                    fingerStates[key] = false;
                }

                // UI Points
                canvasCtx.fillStyle = isBent ? "var(--rec)" : "white";
                canvasCtx.beginPath();
                canvasCtx.arc(x, y, 8, 0, Math.PI*2);
                canvasCtx.fill();
                canvasCtx.fillText(side + " " + names[fIdx], x - 20, y - 15);
            });
        });

        // Loop Logic
        if (rightFist && leftFist) {
            recording = [];
            document.getElementById('rec-ui').innerText = "REC: CLEARED";
        } else if (rightFist) {
            if (!isRecording) {
                isRecording = true; loopStartTime = Date.now();
                document.getElementById('rec-ui').innerText = "REC: ON ðŸ”´";
                document.getElementById('rec-ui').style.color = "red";
            }
        } else {
            isRecording = false;
            document.getElementById('rec-ui').innerText = "REC: OFF";
            document.getElementById('rec-ui').style.color = "white";
        }

        if (leftFist && recording.length > 0 && !isPlaying) {
            playLoop();
        }
    }
    canvasCtx.restore();
}

function playLoop() {
    isPlaying = true;
    document.getElementById('play-ui').innerText = "LOOP: PLAYING ðŸŸ¢";
    recording.forEach(event => {
        setTimeout(() => synth.triggerAttackRelease(event.note, "4n"), event.time);
    });
    // Reset play state after the last note
    const duration = recording[recording.length-1].time + 1000;
    setTimeout(() => { 
        isPlaying = false; 
        document.getElementById('play-ui').innerText = "LOOP: READY";
    }, duration);
}

const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.8 });
hands.onResults(onResults);

function startCamera() {
    new Camera(videoElement, {
        onFrame: async () => {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
            await hands.send({image: videoElement});
        }, width: 1280, height: 720
    }).start();
}
</script>
</body>
</html>
